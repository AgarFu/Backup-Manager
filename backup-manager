#!/bin/bash

# Copyright (C) 2005 The Backup Manager Authors
# See the AUTHORS file for details.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# This is the main backup-manager script. 

set -e

VERSION="0.5.9c"

# All the path we'll need
libdir="/usr/share/backup-manager"
zip="/usr/bin/zip"
bzip="/usr/bin/bzip2"
gzip="/bin/gzip"
tar="/bin/tar"
rsync="/usr/bin/rsync"
mkisofs="/usr/bin/mkisofs"
growisofs="/usr/bin/growisofs"
cdrecord="/usr/bin/cdrecord"
bmu="/usr/bin/backup-manager-upload"
lockfile="/var/run/backup-manager.pid"
md5sum="/usr/bin/md5sum"
bc="/usr/bin/bc"
mysqldump="/usr/bin/mysqldump"
svnadmin="/usr/bin/svnadmin"

# Load the backup-manager's library
source $libdir/gettext.sh
source $libdir/logger.sh
source $libdir/dialog.sh
source $libdir/files.sh
source $libdir/md5sum.sh
source $libdir/backup-methods.sh
source $libdir/actions.sh

# Initialize defautls values of arguments
verbose="false"
version="false"
warnings="true"
force="false"
upload="false"
burn="false"
help="false"
md5check="false"
purge="false"
conffile="/etc/backup-manager.conf"

if [ "$UID" != 0 ]; then
	echo_translated "backup-manager must be run as root."
	exit 1
fi

# Catch signals for a nice exit.
trap stop_me SIGINT SIGTERM SIGKILL

# Parse the command line 
while [ $# -ge 1 ]; do
	case $1 in
		-h|--help)
			usage
		;;
		-m|--md5check) 
			md5check="true"
		;;
		-p|--purge)
			purge="true"
		;;
		--no-purge)
			nopurge="true"
		;;
		-b|--burn) 
			burn="true"
		;;
		--no-burn)
			noburn="true"
		;;
		-u|--upload) 
			upload="true"
		;;
		--no-upload)
			noupload="true"
		;;
		-v|--verbose) 
			verbose="true"
		;;
                --version)
                        echo "Backup Manager $VERSION"
                        _exit 0
                ;;
		--no-warnings)
			warnings="false"
		;;
		-f|--force) 
			force="true"
		;;
		-c|--conffile)
			# in this case, $2 should be the conffile !
			if [ -f $2 ]; then
				conffile=$2
			else
				error "-c option must be followed by an existing filename"
				usage
			fi
			# we shift here to avoid processing the file path 
			shift
		;;
		*)  
			echo "unknown option $1"
			usage
			break
		;;
	esac
	shift
done

# source the wanted conffile...
source $conffile

# ...And check that every conf key is ok
source $libdir/sanitize.sh

# check that no other backup-manager is running
get_lock

# check dependencies on zip, bzip2
check_filetypes

# check the directories list to backup is not empty
check_what_to_backup

# set the default stuff
init_default_vars

# This is the time for pre-command
exec_pre_command || error "Unable to exec the pre-command"

# create $ARCHIVES_REPOSITORY if not exists
create_archive_root_if_not_exists

##############################################################
# Single actions handling
#############################################################

# only the uploading system
if [ "$upload" == "true" ]; then
	upload_files
	_exit 0
fi

# only the burning system
if [ "$burn" == "true" ]; then
	burn_files
	_exit 0
fi

# only the md5 checkup
if [ "$md5check" == "true" ]; then
	check_cdrom_md5_sums
	_exit 0
fi

# only purge old archives
if [ "$purge" == "true" ]; then
	clean_repositories
	_exit 0
fi

##############################################################
# Default process : doing everything unless --no-flags 
# are given.
#############################################################

# first cleanning up the repository 
if [ "$nopurge" != "true" ]; then
	clean_repositories
fi

# now generating new archives...
# FIXME: here we will manage multiple archive method
# like 
#       make_tarballs
#       make_rsync 
#       ....
make_archives

# upload if needed
if [ "$noupload" != "true" ]; then
	upload_files
fi

# burn if wanted
if [ "$noburn" != "true" ]; then
	burn_files
fi

# this is time for post-command
exec_post_command || error "Unable to exec post-command"

# release the lock concerned by this conffile
release_lock

exit 0

